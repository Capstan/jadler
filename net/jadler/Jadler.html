<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_72) on Fri Mar 25 18:53:16 PDT 2016 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Jadler (jadler-pom 1.3.0 API)</title>
<meta name="date" content="2016-03-25">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Jadler (jadler-pom 1.3.0 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Jadler.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../net/jadler/AbstractRequestMatching.html" title="class in net.jadler"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../net/jadler/Jadler.OngoingConfiguration.html" title="class in net.jadler"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?net/jadler/Jadler.html" target="_top">Frames</a></li>
<li><a href="Jadler.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">net.jadler</div>
<h2 title="Class Jadler" class="title">Class Jadler</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>net.jadler.Jadler</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">Jadler</span>
extends <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></pre>
<div class="block"><p>This class is a gateway to the whole Jadler library. Jadler is a powerful yet simple to use 
 http mocking library for writing integration tests in the http environment. It provides a convenient way
 to create a stub http server which serves all http requests sent during a test execution
 by returning stub responses according to defined rules.</p>
 
 <h3>Jadler Usage Basics</h3>
 
 <p>Let's have a simple component with one operation: </p>
 
 <pre>
 public interface AccountManager {
   Account getAccount(String id);
 }
 </pre>
 
 <p>An implementation of the <code>getAccount</code> operation is supposed to send a GET http request to
 <code>/accounts/{id}</code> where <code>{id}</code> stands for the method <code>id</code> parameter, deserialize the http response
 to an <code>Account</code> instance and return it. If there is no such account (the GET request returned 404),
 <code>null</code> must be returned. If some problem occurs (50x http response), a runtime exception must be thrown.</p>
 
 <p>For the integration testing of this component it would be great to have a way to start a stub http server
 which would return predefined stub responses. This is where Jadler comes to help.</p>
 
 <p>Let's write such an integration test using <a href="http://junit.org" target="_blank">jUnit</a>:</p>
 
 <pre> 
 ...
 import static net.jadler.Jadler.*;
 ...
 
 public class AccountManagerImplTest {
 
     private static final String ID = "123";
     private static final String ACCOUNT_JSON = "{\"account\":{\"id\": \"123\"}}";
 

      @Before
     public void setUp() {
         initJadler();
     }
  
      @After
     public void tearDown() {
         closeJadler();
     }
   
      @Test
     public void getAccount() {
         onRequest()
             .havingMethodEqualTo("GET")
             .havingPathEqualTo("/accounts/" + ID)
         .respond()
             .withBody(ACCOUNT_JSON)
             .withStatus(200);
 
         final AccountManager am = new AccountManagerImpl("http", "localhost", port());
 
         final Account account = ag.getAccount(ID);
       
         assertThat(account, is(notNullValue()));
         assertThat(account.getId(), is(ID));
     }
 }
 </pre>
 
 <p>There are three main parts of this test. The <em>setUp</em> phase just initializes Jadler (which includes
 starting a stub http server), while the <em>tearDown</em> phase just closes all resources. Nothing
 interesting so far.</p>
 
 <p>All the magic happens in the test method. New http stub is defined, in the <em>THEN</em> part
 the http stub server is instructed to return a specific http response
 (200 http status with a body defined in the <code>ACCOUNT_JSON</code> constant) if the incoming http request
 fits the given conditions defined in the <em>WHEN</em> part (must be a GET request to <code>/accounts/123</code>).</p>
 
 <p>In order to communicate with the http stub server instead of the real web service, the tested instance
 must be configured to access <code>localhost</code> using the http protocol (https will be supported
 in a latter version of Jadler) connecting to a port which can be retrieved using the <a href="../../net/jadler/Jadler.html#port--"><code>port()</code></a> method.</p>
 
 <p>The rest of the test method is business as usual. The <code>getAccount(String)</code> is executed and some
 assertions are evaluated.</p>
 
 <p>Now lets write two more test methods to test the 404 and 500 scenarios:</p>
 
 <pre>
  @Test
 public void getAccountNotFound() {
     onRequest()
         .havingMethodEqualTo("GET")
         .havingPathEqualTo("/accounts/" + ID)
     .respond()
         .withStatus(404);
 
     final AccountManager am = new AccountManagerImpl("http", "localhost", port());
 
     Account account = am.getAccount(ID);
 
     assertThat(account, is(nullValue()));
 }
 
 
  @Test(expected=RuntimeException.class)
 public void getAccountError() {
     onRequest()
         .havingMethodEqualTo("GET")
         .havingPathEqualTo("/accounts/" + ID)
     .respond()
         .withStatus(500);
 
     final AccountManager am = new AccountManagerImpl("http", "localhost", port());
 
     am.getAccount(ID);
 }
 </pre>
 
 <p>The first test method checks the <code>getAccount(String)</code> method returns <code>null</code> if 404 is returned
 from the server. The second one tests a runtime exception is thrown upon 500 http response.</p>
 
 
 <h3>Multiple responses definition</h3> 
 <p>Sometimes you need to define more subsequent messages in your testing scenario. Let's test here
 your code can recover from an unexpected 500 response and retry the POST receiving 201 this time:</p>
 
 <pre>
 onRequest()
     .havingPathEqualTo("/accounts")
     .havingMethodEqualTo("POST")
 .respond()
     .withStatus(500)
 .thenRespond()
     .withStatus(201);
 </pre>
 
 <p>The stub server will return a stub http response with 500 response status for the first request
 which suits the stub rule. A stub response with 201 response status will be returned for the second request
 (and all subsequent requests as well).</p>
 
 <h3>More suitable stub rules</h3>
 
 <p>It's not uncommon that more stub rules can be applied (the incoming request fits more than one <em>WHEN</em>
 part). Let's have the following example: </p>
 
 <pre>
 onRequest()
     .havingPathEqualTo("/accounts")
 .respond()
     .withStatus(201);
 
 onRequest()
     .havingMethodEqualTo("POST")
 .respond()
     .withStatus(202);
 </pre>
 
 <p>If a POST http request was sent to <code>/accounts</code> both rules would be applicable. However, the latter stub
 gets priority over the former one. In this example, an http response with <code>202</code> status code would be
 returned.</p>
 
 <h3>Advanced http stubbing</h3>
 <h4 id="stubbing">The <em>WHEN</em> part</h4>
 <p>So far two <code>having*</code> methods have been introduced,
 <a href="../../net/jadler/RequestMatching.html#havingMethodEqualTo-java.lang.String-"><code>RequestMatching.havingMethodEqualTo(java.lang.String)</code></a> to check the http method equality and
 <a href="../../net/jadler/RequestMatching.html#havingPathEqualTo-java.lang.String-"><code>RequestMatching.havingPathEqualTo(java.lang.String)</code></a> to check the path equality. But there's more!</p>
 
 <p>You can use <a href="../../net/jadler/RequestMatching.html#havingBodyEqualTo-java.lang.String-"><code>RequestMatching.havingBodyEqualTo(java.lang.String)</code></a> and
 <a href="../../net/jadler/RequestMatching.html#havingRawBodyEqualTo-byte:A-"><code>RequestMatching.havingRawBodyEqualTo(byte[])</code></a>} to check the request body equality
 (either as a string or as an array of bytes).</p>
 
 <p>Feel free to to use <a href="../../net/jadler/RequestMatching.html#havingQueryStringEqualTo-java.lang.String-"><code>RequestMatching.havingQueryStringEqualTo(java.lang.String)</code></a>
 to test the query string value.</p>
 
 <p>And finally don't hesitate to use <a href="../../net/jadler/RequestMatching.html#havingParameterEqualTo-java.lang.String-java.lang.String-"><code>RequestMatching.havingParameterEqualTo(java.lang.String, java.lang.String)</code></a>
 or <a href="../../net/jadler/RequestMatching.html#havingHeaderEqualTo-java.lang.String-java.lang.String-"><code>RequestMatching.havingHeaderEqualTo(java.lang.String, java.lang.String)</code></a>
 for a check whether there is an http parameter / header in the incoming request with a given value.
 If an existence check is sufficient you can use <a href="../../net/jadler/RequestMatching.html#havingParameter-java.lang.String-"><code>RequestMatching.havingParameter(java.lang.String)</code></a>,
 <a href="../../net/jadler/RequestMatching.html#havingParameters-java.lang.String...-"><code>RequestMatching.havingParameters(java.lang.String[])</code></a> or
 <a href="../../net/jadler/RequestMatching.html#havingHeader-java.lang.String-"><code>RequestMatching.havingHeader(java.lang.String)</code></a>, <a href="../../net/jadler/RequestMatching.html#havingHeaders-java.lang.String...-"><code>RequestMatching.havingHeaders(java.lang.String[])</code></a>
 instead.</p>
 
 <p>So let's write some advanced http stub here: </p>
 
 <pre>
 onRequest()
     .havingMethodEqualTo("POST")
     .havingPathEqualTo("/accounts")
     .havingBodyEqualTo("{\"account\":{}}")
     .havingHeaderEqualTo("Content-Type", "application/json")
     .havingParameterEqualTo("force", "1")
 .respond()
     .withStatus(201);
 </pre>
 
 <p>The 201 stub response will be returned if the incoming request was a <code>POST</code> request to <code>/accounts</code>
 with the specified body, <code>application/json</code> content type header and a <code>force</code> http parameter set to
 <code>1</code>.</p>
 
 <h4>The <em>THEN</em> part</h4>
 <p>There are much more options than just setting the http response status using the
 <a href="../../net/jadler/stubbing/ResponseStubbing.html#withStatus-int-"><code>ResponseStubbing.withStatus(int)</code></a> in the <em>THEN</em> part of an http stub.</p>
 
 <p>You will probably have to define the stub response body as a string very often. That's what the 
 <a href="../../net/jadler/stubbing/ResponseStubbing.html#withBody-java.lang.String-"><code>ResponseStubbing.withBody(java.lang.String)</code></a> and
 <a href="../../net/jadler/stubbing/ResponseStubbing.html#withBody-java.io.Reader-"><code>ResponseStubbing.withBody(java.io.Reader)</code></a> methods are for. These
 are very often used in conjunction of
 <a href="../../net/jadler/stubbing/ResponseStubbing.html#withEncoding-java.nio.charset.Charset-"><code>ResponseStubbing.withEncoding(java.nio.charset.Charset)</code></a> to define the
 encoding of the response body</p>
 
 <p>If you'd like to define the stub response body binary, feel free to use either
 <a href="../../net/jadler/stubbing/ResponseStubbing.html#withBody-byte:A-"><code>ResponseStubbing.withBody(byte[])</code></a> or
 <a href="../../net/jadler/stubbing/ResponseStubbing.html#withBody-java.io.InputStream-"><code>ResponseStubbing.withBody(java.io.InputStream)</code></a>.</p>
 
 <p>Setting a stub response header is another common http stubbing use case. Just call
 <a href="../../net/jadler/stubbing/ResponseStubbing.html#withHeader-java.lang.String-java.lang.String-"><code>ResponseStubbing.withHeader(java.lang.String, java.lang.String)</code></a> to 
 set such header. For setting the <code>Content-Type</code> header you can use specially tailored
 <a href="../../net/jadler/stubbing/ResponseStubbing.html#withContentType-java.lang.String-"><code>ResponseStubbing.withContentType(java.lang.String)</code></a> method.</p>
 
 <p>And finally sometimes you would like to simulate a network latency. To do so just call the
 <a href="../../net/jadler/stubbing/ResponseStubbing.html#withDelay-long-java.util.concurrent.TimeUnit-"><code>ResponseStubbing.withDelay(long, java.util.concurrent.TimeUnit)</code></a> method.
 The stub response will be returned after the specified amount of time or later.</p>
 
 <p>Let's define the <em>THEN</em> part precisely:</p>
 
 <pre>
 onRequest()
     .havingMethodEqualTo("POST")
     .havingPathEqualTo("/accounts")
     .havingBodyEqualTo("{\"account\":{}}")
     .havingHeaderEqualTo("Content-Type", "application/json")
     .havingParameterEqualTo("force", "1")
 .respond()
     .withDelay(2, SECONDS)
     .withStatus(201)
     .withBody("{\"account\":{\"id\" : 1}}")
     .withEncoding(Charset.forName("UTF-8"))
     .withContentType("application/json; charset=UTF-8")
     .withHeader("Location", "/accounts/1");
 </pre>
 
 <p>If the incoming http request fulfills the <em>WHEN</em> part, a stub response will be returned after at least 
 2 seconds. The response will have 201 status code, defined json body encoded using UTF-8 and both
 <code>Content-Type</code> and <code>Location</code> headers set to proper values.</p>
 
 
 <h3> Even more advanced http stubbing</h3>
 
 <h4>Fine-tuning the <em>WHEN</em> part using predicates</h4>
 <p>So far we have been using the equality check to define the <em>WHEN</em> part. However it's quite useful
 to be able to use other predicates (<em>non empty string</em>, <em>contains string</em>, ...) then just
 the request value equality.</p>
 
 <p>Jadler uses <a href="http://hamcrest.org" target="_blank">Hamcrest</a> as a predicates library. Not only
 it provides many already implemented predicates (called matchers) but also a simple way to implement
 your own ones if necessary. More on Hamcrest usage to be found in this
 <a href="http://code.google.com/p/hamcrest/wiki/Tutorial" target="_blank">tutorial</a>.</p>
 
 <p>So let's write the following stub: if an incoming request has a non-empty body and the request method
 is not PUT and the path value starts with <em>/accounts</em> then return an empty response
 with the 200 http status:</p>
 
 <pre>
 onRequest()
     .havingBody(not(isEmptyOrNullString()))
     .havingPath(startsWith("/accounts"))
     .havingMethod(not(equalToIgnoringCase("PUT")))
 .respond()
     .withStatus(200);
 </pre>
 
 <p>You can use following <em>having*</em> methods for defining the <em>WHEN</em> part
 using a Hamcrest string matcher: </p>
 
 <ul>
   <li><a href="../../net/jadler/RequestMatching.html#havingBody-org.hamcrest.Matcher-"><code>RequestMatching.havingBody(org.hamcrest.Matcher)</code></a></li>
   <li><a href="../../net/jadler/RequestMatching.html#havingMethod-org.hamcrest.Matcher-"><code>RequestMatching.havingMethod(org.hamcrest.Matcher)</code></a></li>
   <li><a href="../../net/jadler/RequestMatching.html#havingQueryString-org.hamcrest.Matcher-"><code>RequestMatching.havingQueryString(org.hamcrest.Matcher)</code></a></li>
   <li><a href="../../net/jadler/RequestMatching.html#havingPath-org.hamcrest.Matcher-"><code>RequestMatching.havingPath(org.hamcrest.Matcher)</code></a></li>
 </ul>
 
 <p>For adding predicates about request parameters and headers use
 <a href="../../net/jadler/RequestMatching.html#havingHeader-java.lang.String-org.hamcrest.Matcher-"><code>RequestMatching.havingHeader(java.lang.String, org.hamcrest.Matcher)</code></a> and
 <a href="../../net/jadler/RequestMatching.html#havingParameter-java.lang.String-org.hamcrest.Matcher-"><code>RequestMatching.havingParameter(java.lang.String, org.hamcrest.Matcher)</code></a> methods. Since a request header or 
 parameter can have more than one value, these methods accept a list of strings predicates.</p>
 
 <p>All introduced methods allow user to add a predicate about a part of an http request (body, method, ...).
 If you need to add a predicate about the whole request object (of type <a href="../../net/jadler/Request.html" title="class in net.jadler"><code>Request</code></a>),
 you can use the <a href="../../net/jadler/RequestMatching.html#that-org.hamcrest.Matcher-"><code>RequestMatching.that(org.hamcrest.Matcher)</code></a> method: </p>
 
 <pre>
   //meetsCriteria() is some factory method returning a Matcher&lt;Request&gt; instance
 
 onRequest()
     .that(meetsCriteria())
 .respond()
     .withStatus(204);
 </pre>
 
 
 <h4>Fine-tuning the <em>THEN</em> part using defaults</h4>
 
 <p>It's pretty common many <em>THEN</em> parts share similar settings. Let's have two or more stubs returning
 an http response with 200 http status. Instead of calling <a href="../../net/jadler/stubbing/ResponseStubbing.html#withStatus-int-"><code>ResponseStubbing.withStatus(int)</code></a> during
 every stubbing Jadler can be instructed to use 200 as a default http status: </p>
 
 <pre>
  @Before
 public void setUp() {
     initJadler()
         .withDefaultResponseStatus(200);
 }
 </pre>
 
 <p>This particular test setup configures Jadler to return http stub responses with 200 http
 status by default. This default can always be overwritten by calling the <a href="../../net/jadler/stubbing/ResponseStubbing.html#withStatus-int-"><code>ResponseStubbing.withStatus(int)</code></a> 
 method in the particular stubbing.</p>
 
 <p>The following example demonstrates all response defaults options: </p>
 
 <pre>
    @Before
   public void setUp() {
       initJadler()
           .withDefaultResponseStatus(202)
           .withDefaultResponseContentType("text/plain")
           .withDefaultResponseEncoding(Charset.forName("ISO-8859-1"))
           .withDefaultResponseHeader("X-DEFAULT-HEADER", "default_value");
   }
 </pre>
 
 <p>If not redefined in the particular stubbing, every stub response will have 202 http status, <code>Content-Type</code>
 header set to <code>text/plain</code>, response body encoded using <code>ISO-8859-1</code> and a header named
 <code>X-DEFAULT-HEADER</code> set to <code>default_value</code>.</p>
 
 <p>And finally if no default nor stubbing-specific status code is defined 200 will be used. And if no default 
 nor stubbing-specific response body encoding is defined, <code>UTF-8</code> will be used by default.</p>
 
 
 <h3>Generating a stub response dynamically</h3>
 
 <p>In some integration testing scenarios it's necessary to generate a stub http response dynamically. This
 is a case where the <code>with*</code> methods aren't sufficient. However Jadler comes to help here with with
 the <a href="../../net/jadler/stubbing/Responder.html" title="interface in net.jadler.stubbing"><code>Responder</code></a> interface which allows to define the stub response dynamically
 according to the received request: </p>
 
 <pre>
 onRequest()
     .havingMethodEqualTo("POST")
     .havingPathEqualTo("/accounts")
     .respondUsing(new Responder() {

         private final AtomicInteger cnt = new AtomicInteger(1);
 
          @Override
         public StubResponse nextResponse(final Request request) {
              final int current = cnt.getAndIncrement();
              final String headerValue = request.getHeaders().getValue("x-custom-request-header");
              return StubResponse.builder()
                      .status(current % 2 == 0 ? 200 : 500)
                      .header("x-custom-response-header", headerValue)
                      .build();
         }
     });
 </pre>
 
 <p>The intention to define the stub response dynamically is expressed by using
 <a href="../../net/jadler/stubbing/RequestStubbing.html#respondUsing-net.jadler.stubbing.Responder-"><code>RequestStubbing.respondUsing(net.jadler.stubbing.Responder)</code></a>. This method takes
 a <a href="../../net/jadler/stubbing/Responder.html" title="interface in net.jadler.stubbing"><code>Responder</code></a> implementation as a parameter, Jadler subsequently uses the
 <a href="../../net/jadler/stubbing/Responder.html#nextResponse-net.jadler.Request-"><code>Responder.nextResponse(net.jadler.Request)</code></a> method to generate stub responses for
 all requests fitting the given <em>WHEN</em> part.</p>
 
 <p>In the previous example the http status of a stub response is <code>200</code> for even requests and <code>500</code>
 for odd requests. And the value of the <code>x-custom-request-header</code> request header is used as
 a response header.</p>
 
 <p>As you can see in the example this <a href="../../net/jadler/stubbing/Responder.html" title="interface in net.jadler.stubbing"><code>Responder</code></a> implementation is thread-safe 
 (by using <a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/atomic/AtomicInteger.html?is-external=true" title="class or interface in java.util.concurrent.atomic"><code>AtomicInteger</code></a> here). This is important for tests of parallel nature
 (more than one client can send requests fitting the <em>WHEN</em> part in parallel). Of course if requests are sent
 in a serial way (which is the most common case) there is no need for the thread-safety of the implementation.</p>
 
 <p>Please note this dynamic way of defining stub responses should be used as rarely as possible as
 it very often signalizes a problem either with test granularity or somewhere in the tested code. However there
 could be very specific testing scenarios where this functionality might be handy.</p>
 
 
 <h3>Request Receipt Verification</h3>
 
 <p>While the Jadler library is invaluable in supporting your test scenarios by providing a stub http server,
 it has even more to offer.</p>
 
 <p>Very often it's necessary not only to provide a stub http response but also to verify that a specific
 http request was received during a test execution. Let's add a removal operation to the already introduced
 <code>AccountManager</code> interface: </p>
 
 <pre>
 public interface AccountManager {
   Account getAccount(String id);
 
   void deleteAccount(String id);
 }
 </pre>
 
 <p>The <code>deleteAccount</code> operation is supposed to delete an account by sending a <code>DELETE</code> http request
 to <code>/accounts/{id}</code> where <code>{id}</code> stands for the operation <code>id</code> parameter. If the response status is
 204 the removal is considered successful and the execution is finished successfully. Let's write an integration
 test for this scenario:</p>
 
 <pre>
 ...
 import static net.jadler.Jadler.*;
 ...
 
 public class AccountManagerImplTest {
 
     private static final String ID = "123";

      @Before
     public void setUp() {
         initJadler();
     }
  
      @After
         public void tearDown() {
         closeJadler();
     }
   
      @Test
     public void deleteAccount() {
         onRequest()
             .havingMethodEqualTo("DELETE")
             .havingPathEqualTo("/accounts/" + ID)
         .respond()
             .withStatus(204);
 
         final AccountManager am = new AccountManagerImpl("http", "localhost", port());
 
         final Account account = am.deleteAccount(ID);
       
         verifyThatRequest()
             .havingMethodEqualTo("DELETE")
             .havingPathEqualTo("/accounts/" + ID)
           .receivedOnce();
     }
 }
 </pre>
 
 <p>The first part of this test is business as usual. An http stub is created and the tested method
 <code>deleteAccount</code> is invoked. However in this test case we would like to test whether the <code>DELETE</code> http
 request was really sent during the execution of the method.</p>
 
 <p>This is where Jadler comes again to help. Calling <a href="../../net/jadler/Jadler.html#verifyThatRequest--"><code>verifyThatRequest()</code></a> signalizes an intention to
 verify a number of requests received so far meeting the given criteria. The criteria is defined using exactly
 the same <code>having*</code> methods which has been already described in the <a href="#stubbing">stubbing section</a>
 (the methods are defined in the <a href="../../net/jadler/RequestMatching.html" title="interface in net.jadler"><code>RequestMatching</code></a> interface).</p>
 
 <p>The request definition must be followed by calling one of the <code>received*</code> methods. The already
 introduced <a href="../../net/jadler/mocking/Verifying.html#receivedOnce--"><code>Verifying.receivedOnce()</code></a> method verifies there has been received exactly one request meeting
 the given criteria so far. If the verification fails a <a href="../../net/jadler/mocking/VerificationException.html" title="class in net.jadler.mocking"><code>VerificationException</code></a> instance is thrown and
 the exact reason is logged on the <code>INFO</code> level.</p>
 
 <p>There are three more verification methods. <a href="../../net/jadler/mocking/Verifying.html#receivedNever--"><code>Verifying.receivedNever()</code></a> verifies there has not been
 received any request meeting the given criteria so far. <a href="../../net/jadler/mocking/Verifying.html#receivedTimes-int-"><code>Verifying.receivedTimes(int)</code></a> allows to define
 the exact number of requests meeting the given criteria. And finally
 <a href="../../net/jadler/mocking/Verifying.html#receivedTimes-org.hamcrest.Matcher-"><code>Verifying.receivedTimes(org.hamcrest.Matcher)</code></a> allows to apply a Hamcrest matcher on the number of
 requests meeting the given criteria. The following example shows how to verify there have been at most
 3 DELETE requests sent so far:</p>
 
 <pre>
 verifyThatRequest()
     .havingMethodEqualTo("DELETE")
 .receivedTimes(lessThan(4));
 </pre>
 
 <p>This verification feature is implemented by recording all incoming http requests (including their bodies). In
 some very specific corner cases this implementation can cause troubles. For example imagine a long running
 performance test using Jadler for stubbing some remote http service. Since such a test can issue thousands
 or even millions of requests the memory consumption probably would affect the test results (either
 by a performance slowdown or even crashes). In this specific scenarios you should consider disabling
 the incoming requests recording:</p>
 
 <pre>
  @Before
 public void setUp() {
     initJadler()
             .withRequestsRecordingDisabled();
 }
 </pre>
 
 <p>Once the request recording has been disabled, calling <a href="../../net/jadler/mocking/Mocker.html#verifyThatRequest--"><code>Mocker.verifyThatRequest()</code></a>
 will result in <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalStateException.html?is-external=true" title="class or interface in java.lang"><code>IllegalStateException</code></a>.</p>
 
 <p>Please note you should ignore this option almost every time you use Jadler unless you are really
 convinced about it. Because premature optimization is the root of all evil, you know.</p>
 
 <h3>Jadler Lifecycle</h3>
 
 <p>As already demonstrated, the standard Jadler lifecycle consists of the following steps: </p>
 
 <ol>
   <li>starting Jadler including the underlying http server (by calling one of the <code>initJadler*</code> methods of the
   <a href="../../net/jadler/Jadler.html" title="class in net.jadler"><code>Jadler</code></a> facade) in the <em>setUp</em> phase of a test</li>
 
   <li>stubbing using the <a href="../../net/jadler/Jadler.html#onRequest--"><code>onRequest()</code></a> method at the beginning of the test method</li>
 
   <li>calling the code to be tested</li>
 
   <li>doing some verification using <a href="../../net/jadler/Jadler.html#verifyThatRequest--"><code>verifyThatRequest()</code></a> if necessary</li>
 
   <li>closing Jadler including the underlying http server (by calling the <a href="../../net/jadler/Jadler.html#closeJadler--"><code>closeJadler()</code></a>) method
   in the <em>tearDown</em> phase of a test</li>
 </ol>
 
 <p>These steps are then repeated for every test in a test suite. This lifecycle is fully covered by the static
 <a href="../../net/jadler/Jadler.html" title="class in net.jadler"><code>Jadler</code></a> facade which encapsulates and manages an instance of the core <a href="../../net/jadler/JadlerMocker.html" title="class in net.jadler"><code>JadlerMocker</code></a> component.</p>
 
 <h4>Creating mocker instances manually</h4>
 
 <p>There are few specific scenarios when creating <a href="../../net/jadler/JadlerMocker.html" title="class in net.jadler"><code>JadlerMocker</code></a> instances manually (instead of using the 
 <a href="../../net/jadler/Jadler.html" title="class in net.jadler"><code>Jadler</code></a> facade) can be handy. Some specific integration tests may require starting more than just one mocker
 on different ports (simulating requesting multiple different http servers). If this is the case,
 all the mocker instances have to be created manually (since the facade encapsulates just one mocker instance).</p>
 
 <p>To achieve this each mocker must be created and disposed before and after every test: </p>
 
 <pre>
 public class ManualTest {
 
     private JadlerMocker mocker;
     private int port;
 
      @Before
     public void setUp() {
         mocker = new JadlerMocker(new JettyStubHttpServer());
         mocker.start();
         port = getStubHttpServerPort();
     }
 
      @After
     public void tearDown() {
         mocker.close();
     }
 
      @Test
     public void testSomething() {
         mocker.onRequest().respond().withStatus(404);
     
           //call the code to be tested here

         mocker.verifyThatRequest().receivedOnce();
     }
 }
 </pre>
 
 
 <h4>Simplified Jadler Lifecycle Management</h4>
 
 <p>In all previous examples the jUnit @Before and @After sections were used to manage
 the Jadler lifecycle. If jUnit 4.11 (or newer) is on the classpath a simple Jadler 
 <a href="https://github.com/junit-team/junit/wiki/Rules">rule</a> <a href="../../net/jadler/junit/rule/JadlerRule.html" title="class in net.jadler.junit.rule"><code>JadlerRule</code></a>
 can be used instead:</p>
 
 <pre>
 public class AccountManagerImplTest {

      @Rule
     public JadlerRule jadlerRule = new JadlerRule();
 
     ...
 }
 </pre>
 
 <p>This piece of code starts Jadler on a random port at the beginning of each test and closes it at the end.
 A specific port can be defined as well: <code>new JadlerRule(12345);</code>. Please note this is exactly the same as
 calling <a href="../../net/jadler/Jadler.html#initJadler--"><code>initJadler()</code></a> and <a href="../../net/jadler/Jadler.html#closeJadler--"><code>closeJadler()</code></a> in the <code>setUp</code> and <code>tearDown</code>
 methods.</p>
 
 <p>To use this rule the <code>jadler-junit</code> artifact must be on the classpath.</p></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../net/jadler/Jadler.OngoingConfiguration.html" title="class in net.jadler">Jadler.OngoingConfiguration</a></span></code>
<div class="block">This class serves as a DSL support for additional Jadler configuration.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../net/jadler/Jadler.html#closeJadler--">closeJadler</a></span>()</code>
<div class="block">Stops the underlying <a href="../../net/jadler/stubbing/server/StubHttpServer.html" title="interface in net.jadler.stubbing.server"><code>StubHttpServer</code></a> and closes Jadler.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static <a href="../../net/jadler/Jadler.OngoingConfiguration.html" title="class in net.jadler">Jadler.OngoingConfiguration</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../net/jadler/Jadler.html#initJadler--">initJadler</a></span>()</code>
<div class="block">Initializes Jadler and starts a default stub server <a href="../../net/jadler/stubbing/server/jetty/JettyStubHttpServer.html" title="class in net.jadler.stubbing.server.jetty"><code>JettyStubHttpServer</code></a>
 serving the http protocol listening on any free port.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static <a href="../../net/jadler/Jadler.OngoingConfiguration.html" title="class in net.jadler">Jadler.OngoingConfiguration</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../net/jadler/Jadler.html#initJadlerListeningOn-int-">initJadlerListeningOn</a></span>(int&nbsp;port)</code>
<div class="block">Initializes Jadler and starts a default stub server <a href="../../net/jadler/stubbing/server/jetty/JettyStubHttpServer.html" title="class in net.jadler.stubbing.server.jetty"><code>JettyStubHttpServer</code></a>
 serving the http protocol listening on the given port.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static <a href="../../net/jadler/Jadler.OngoingConfiguration.html" title="class in net.jadler">Jadler.OngoingConfiguration</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../net/jadler/Jadler.html#initJadlerUsing-net.jadler.stubbing.server.StubHttpServer-">initJadlerUsing</a></span>(<a href="../../net/jadler/stubbing/server/StubHttpServer.html" title="interface in net.jadler.stubbing.server">StubHttpServer</a>&nbsp;server)</code>
<div class="block">Initializes Jadler and starts the given <a href="../../net/jadler/stubbing/server/StubHttpServer.html" title="interface in net.jadler.stubbing.server"><code>StubHttpServer</code></a>.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static <a href="../../net/jadler/stubbing/RequestStubbing.html" title="interface in net.jadler.stubbing">RequestStubbing</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../net/jadler/Jadler.html#onRequest--">onRequest</a></span>()</code>
<div class="block">Starts new http stubbing (defining new <i>WHEN</i>-<i>THEN</i> rule).</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../net/jadler/Jadler.html#port--">port</a></span>()</code>
<div class="block">Use this method to retrieve the port the underlying http stub server is listening on</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../net/jadler/Jadler.html#resetJadler--">resetJadler</a></span>()</code>
<div class="block">Resets Jadler by clearing all previously created stubs as well as stored received requests.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static <a href="../../net/jadler/mocking/Verifying.html" title="class in net.jadler.mocking">Verifying</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../net/jadler/Jadler.html#verifyThatRequest--">verifyThatRequest</a></span>()</code>
<div class="block">Starts new verification (checking that an http request with given properties was or was not received)</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></h3>
<code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#clone--" title="class or interface in java.lang">clone</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#equals-java.lang.Object-" title="class or interface in java.lang">equals</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#finalize--" title="class or interface in java.lang">finalize</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#getClass--" title="class or interface in java.lang">getClass</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#hashCode--" title="class or interface in java.lang">hashCode</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#notify--" title="class or interface in java.lang">notify</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#notifyAll--" title="class or interface in java.lang">notifyAll</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#toString--" title="class or interface in java.lang">toString</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait--" title="class or interface in java.lang">wait</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait-long-" title="class or interface in java.lang">wait</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait-long-int-" title="class or interface in java.lang">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="initJadler--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initJadler</h4>
<pre>public static&nbsp;<a href="../../net/jadler/Jadler.OngoingConfiguration.html" title="class in net.jadler">Jadler.OngoingConfiguration</a>&nbsp;initJadler()</pre>
<div class="block"><p>Initializes Jadler and starts a default stub server <a href="../../net/jadler/stubbing/server/jetty/JettyStubHttpServer.html" title="class in net.jadler.stubbing.server.jetty"><code>JettyStubHttpServer</code></a>
 serving the http protocol listening on any free port. The port number can be retrieved using <a href="../../net/jadler/Jadler.html#port--"><code>port()</code></a>.</p>
 
 <p>This should be preferably called in the <code>setUp</code> method of the test suite.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>if additional tweaking needed on the initialized Jadler, call <code>AdditionalConfiguration#that()</code>
 to add more configuration</dd>
</dl>
</li>
</ul>
<a name="initJadlerListeningOn-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initJadlerListeningOn</h4>
<pre>public static&nbsp;<a href="../../net/jadler/Jadler.OngoingConfiguration.html" title="class in net.jadler">Jadler.OngoingConfiguration</a>&nbsp;initJadlerListeningOn(int&nbsp;port)</pre>
<div class="block"><p>Initializes Jadler and starts a default stub server <a href="../../net/jadler/stubbing/server/jetty/JettyStubHttpServer.html" title="class in net.jadler.stubbing.server.jetty"><code>JettyStubHttpServer</code></a>
 serving the http protocol listening on the given port.</p>
 
 <p>This should be preferably called in the <code>setUp</code> method of the test suite.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>port</code> - port the stub server will be listening on</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>if additional tweaking needed on the initialized Jadler, call <code>AdditionalConfiguration#that()</code>
 to add more configuration</dd>
</dl>
</li>
</ul>
<a name="initJadlerUsing-net.jadler.stubbing.server.StubHttpServer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initJadlerUsing</h4>
<pre>public static&nbsp;<a href="../../net/jadler/Jadler.OngoingConfiguration.html" title="class in net.jadler">Jadler.OngoingConfiguration</a>&nbsp;initJadlerUsing(<a href="../../net/jadler/stubbing/server/StubHttpServer.html" title="interface in net.jadler.stubbing.server">StubHttpServer</a>&nbsp;server)</pre>
<div class="block"><p>Initializes Jadler and starts the given <a href="../../net/jadler/stubbing/server/StubHttpServer.html" title="interface in net.jadler.stubbing.server"><code>StubHttpServer</code></a>.</p>
 
 <p>This should be preferably called in the <code>setUp</code> method of the test suite</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>server</code> - stub http server instance</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>if additional tweaking needed on the initialized Jadler, call <code>AdditionalConfiguration#that()</code>
 to add more configuration</dd>
</dl>
</li>
</ul>
<a name="closeJadler--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closeJadler</h4>
<pre>public static&nbsp;void&nbsp;closeJadler()</pre>
<div class="block"><p>Stops the underlying <a href="../../net/jadler/stubbing/server/StubHttpServer.html" title="interface in net.jadler.stubbing.server"><code>StubHttpServer</code></a> and closes Jadler.</p>
 
 <p>This should be preferably called in the <code>tearDown</code> method of a test suite.</p></div>
</li>
</ul>
<a name="resetJadler--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resetJadler</h4>
<pre>public static&nbsp;void&nbsp;resetJadler()</pre>
<div class="block"><p>Resets Jadler by clearing all previously created stubs as well as stored received requests.</p>

 <p>While the standard Jadler lifecycle consists of initializing Jadler and starting the
 underlying stub server (using <a href="../../net/jadler/Jadler.html#initJadler--"><code>initJadler()</code></a>) in the <em>setUp</em> section of a test and stopping
 the server (using <a href="../../net/jadler/Jadler.html#closeJadler--"><code>closeJadler()</code></a>) in the <em>tearDown</em> section, in some specific scenarios
 it could be useful to reuse initialized Jadler in all tests instead.</p>

 <p>Here's an example code using jUnit which demonstrates usage of this method in a test lifecycle:</p>

 <pre>
 public class JadlerResetIntegrationTest {

      @BeforeClass
     public static void beforeTests() {
         initJadler();
     }

      @AfterClass
     public static void afterTests() {
         closeJadler();
     }

      @After
     public void reset() {
         resetJadler();
     }

      @Test
     public void test1() {
         mocker.onRequest().respond().withStatus(201);

         //do an http request here, 201 should be returned from the stub server

         verifyThatRequest().receivedOnce();
     }

      @Test
     public void test2() {
         mocker.onRequest().respond().withStatus(400);

         //do an http request here, 400 should be returned from the stub server

         verifyThatRequest().receivedOnce();
     }
 }
 </pre>
 
 <p>Please note the standard lifecycle should be always preferred since it ensures a full independence
 of all tests in a suite. However performance issues may appear theoretically while starting and stopping
 the server as a part of each test. If this is your case the alternative lifecycle might be handy.</p>
 
 <p>Also note that calling this method in a test body <strong>always</strong> signalizes a poorly written test
 with a problem with the granularity. In this case consider writing more fine grained tests instead of using this
 method.</p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../net/jadler/JadlerMocker.html#reset--"><code>JadlerMocker.reset()</code></a></dd>
</dl>
</li>
</ul>
<a name="port--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>port</h4>
<pre>public static&nbsp;int&nbsp;port()</pre>
<div class="block">Use this method to retrieve the port the underlying http stub server is listening on</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the port the underlying http stub server is listening on</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalStateException.html?is-external=true" title="class or interface in java.lang">IllegalStateException</a></code> - if Jadler has not been initialized yet</dd>
</dl>
</li>
</ul>
<a name="onRequest--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onRequest</h4>
<pre>public static&nbsp;<a href="../../net/jadler/stubbing/RequestStubbing.html" title="interface in net.jadler.stubbing">RequestStubbing</a>&nbsp;onRequest()</pre>
<div class="block">Starts new http stubbing (defining new <i>WHEN</i>-<i>THEN</i> rule).</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>stubbing object for ongoing stubbing</dd>
</dl>
</li>
</ul>
<a name="verifyThatRequest--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>verifyThatRequest</h4>
<pre>public static&nbsp;<a href="../../net/jadler/mocking/Verifying.html" title="class in net.jadler.mocking">Verifying</a>&nbsp;verifyThatRequest()</pre>
<div class="block">Starts new verification (checking that an http request with given properties was or was not received)</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>verifying object for ongoing verifying</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Jadler.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../net/jadler/AbstractRequestMatching.html" title="class in net.jadler"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../net/jadler/Jadler.OngoingConfiguration.html" title="class in net.jadler"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?net/jadler/Jadler.html" target="_top">Frames</a></li>
<li><a href="Jadler.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2016. All Rights Reserved.</small></p>
</body>
</html>
